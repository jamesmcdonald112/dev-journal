### **Purpose**

  

Tests **sendInfoPackHandler** logic in isolation:

- **Human path** calls deliverInfoPack
    
- **Bot path (honeypot hit)** does **not** call deliverInfoPack but still returns success
    
- **Error path** captures with Sentry and throws ActionError
    

  

This is **not** testing UI, network, Resend, or Google Sheets.

---

### **Why mocks are used**

  

We don’t want tests to:

- send real emails
    
- write to Sheets
    
- send real Sentry events
    

  

So we replace imports with fake functions (“mocks”) and assert how they were called.

---

### **Mock setup (what it does)**

```
const { captureExceptionMock, deliverInfoPackMock } = vi.hoisted(() => ({
  captureExceptionMock: vi.fn(),
  deliverInfoPackMock: vi.fn(),
}));

vi.mock("@sentry/astro", () => ({
  captureException: captureExceptionMock,
}));

vi.mock("../../../../src/features/InfoPack/service/deliverInfoPack", () => ({
  deliverInfoPack: deliverInfoPackMock,
}));
```

- vi.fn() creates a **mock function** (records calls, args, etc.).
    
- vi.hoisted(...) ensures these mocks exist **before** Vitest hoists the vi.mock(...) calls.
    
- vi.mock(modulePath, factory) means: _when code imports from that module, use these replacements instead_.
    

---

### **Base input**

```
const baseInput = {
  fullName: "Ada Lovelace",
  email: "ada@example.com",
  phone: "+12345",
  website: "",
};
```

---

### **Tests (what each guarantees)**

  

#### **1) Human submission calls the service**

```
deliverInfoPackMock.mockResolvedValueOnce(undefined);

const result = await sendInfoPackHandler(baseInput);

expect(deliverInfoPackMock).toHaveBeenCalledOnce();
expect(deliverInfoPackMock).toHaveBeenCalledWith(baseInput);
expect(result).toEqual({ success: true, message: "Info pack emailed successfully" });
expect(captureExceptionMock).not.toHaveBeenCalled();
```

- mockResolvedValueOnce(undefined) simulates an async function succeeding.
    

  

#### **2) Honeypot hit skips the service (silent block)**

```
const result = await sendInfoPackHandler({ ...baseInput, website: "x" });

expect(deliverInfoPackMock).not.toHaveBeenCalled();
expect(result).toEqual({ success: true, message: "OK" });
expect(captureExceptionMock).not.toHaveBeenCalled();
```

#### **3) Service error is captured + wrapped in ActionError**

```
const emailError = new Error("fail");
deliverInfoPackMock.mockRejectedValueOnce(emailError);

await expect(sendInfoPackHandler(baseInput)).rejects.toBeInstanceOf(ActionError);
expect(captureExceptionMock).toHaveBeenCalledWith(emailError);
```

- mockRejectedValueOnce(err) simulates async failure.
    

---

### **Why this test file matters**

- Proves spam protection is enforced **server-side**
    
- Proves external side effects are behind a service boundary
    
- Proves error handling is predictable and doesn’t leak raw errors