## **Allowed Origins (Origin Allowlist) — Astro Action Hardening**

  

### **What problem this solves**

  

Blocks **cross-site form submissions** to your Astro Action from random websites by only accepting requests whose Origin header matches a known allowlist.

  

This is **not full CSRF protection**. It’s a strong “cheap gate” that reduces abuse for public forms.

---

### **How it works (high level)**

1. You define a comma-separated env var of allowed domains:
    

  

- ALLOWED_ORIGINS="https://example.com,https://www.example.com"
    

  

2. On every action call, read the request Origin header:
    

  

- If allowlist is configured and:
    
    - Origin is missing **or**
        
    - Origin is not in the allowlist
        
        → reject with ActionError({ code: "FORBIDDEN" })
        
    

  

3. If allowlist is not configured, the origin check is skipped (dev convenience).
    

---

### **File:** 

### **src/features/InfoPack/config/allowed-origins.ts**

```
export function getAllowedOrigins(): Set<string> {
  const rawAllowedOrigins = import.meta.env.ALLOWED_ORIGINS ?? "";
  return new Set(
    rawAllowedOrigins
      .split(",")
      .map((s) => s.trim())
      .filter(Boolean),
  );
}
```

Key points:

- .split(",") turns "a,b,c" into an array.
    
- .trim() removes whitespace around entries.
    
- .filter(Boolean) removes empty strings (e.g. trailing commas).
    
- Set gives fast lookup: allowedOrigins.has(origin).
    

---

### **File:** 

### **src/features/InfoPack/actions/sendInfoPack.ts**

```
const allowedOrigins = getAllowedOrigins();
if (allowedOrigins.size > 0) {
  const origin = context?.request.headers.get("origin");
  if (!origin || !allowedOrigins.has(origin)) {
    throw new ActionError({
      code: "FORBIDDEN",
      message: INFO_PACK_ERRORS.action.forbidden,
    });
  }
}
```

Why it’s written like this:

- allowedOrigins.size > 0: only enforce the rule when configured.
    
- context?.request...: context exists when Astro calls the action handler; tests can pass it in manually.
    
- Origin is checked on the server (client checks are useless for security).
    

---

### **Where** 

### **context**

###  **comes from**

  

Astro Actions call your handler as:

```
handler: async (input, context) => { ... }
```

context is a subset of Astro’s request context and includes request, so you can access headers.

---

### **Required env setup**

  

Set ALLOWED_ORIGINS for **Preview + Production** (and local if you want strict dev):

- https://yourdomain.com
    
- https://www.yourdomain.com
    
- include any other real domains you use for the same form
    

  

If you don’t set it, origin allowlisting is effectively off.

---

### **What this does NOT do**

- Doesn’t stop bots that directly POST to your action endpoint with a spoofed/missing Origin (some clients can omit it).
    
- Doesn’t replace **rate limiting**.
    
- Doesn’t replace real CSRF tokens for authenticated user actions.
    

---

### **Tests added (what they prove)**

- Allowed origin → handler proceeds.
    
- Disallowed origin → throws ActionError with code FORBIDDEN.
    
- Missing origin (when allowlist enabled) → blocked.
    

---

### **Practical checklist**

- Add ALLOWED_ORIGINS to Vercel env vars (Preview + Production)
    
- Confirm the exact scheme matches (https:// vs http://)
    
- Add/verify INFO_PACK_ERRORS.action.forbidden
    
- Keep this check _before_ side-effects (email/sheets)
    

  