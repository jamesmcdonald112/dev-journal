Here’s a **clean, tightened rewrite** of your notes so they’re accurate, readable, and Obsidian-ready. I’ve removed repetition, clarified intent, and kept only what matters.

---

## **Allowed Origins (Origin Allowlist) — Astro Action Hardening**

  

### **What problem this solves**

  

Prevents **cross-site form submissions** to your Astro Action by only accepting requests whose **Origin header** matches a known allowlist.

  

This blocks random websites from posting to your public form endpoint.

  

> ⚠️ This is **not full CSRF protection**.

> It is a **cheap, effective first gate** for unauthenticated public forms.

---

## **How it works (high level)**

1. Define a comma-separated list of allowed origins in env:
    

```
ALLOWED_ORIGINS="https://example.com,https://www.example.com"
```

1.   
    
2. On every action call:
    
    - Read the request’s Origin header
        
    - If an allowlist exists and:
        
        - the Origin is missing **or**
            
        - the Origin is not in the allowlist
            
            → reject the request with ActionError({ code: "FORBIDDEN" })
            
        
    
3. If ALLOWED_ORIGINS is **not configured**, the check is skipped
    
    (useful for early dev, but should not be skipped in production).
    

---

## **Implementation**

  

### **File:**

### **src/features/InfoPack/config/allowed-origins.ts**

```
export function getAllowedOrigins(): Set<string> {
  const rawAllowedOrigins = import.meta.env.ALLOWED_ORIGINS ?? "";
  return new Set(
    rawAllowedOrigins
      .split(",")
      .map((s) => s.trim())
      .filter(Boolean),
  );
}
```

**Why this looks like this**

- .split(",") → converts "a,b,c" into an array
    
- .trim() → removes whitespace around entries
    
- .filter(Boolean) → removes empty strings (e.g. trailing commas)
    
- Set → fast, exact lookups using .has(origin)
    

---

### **File:**

### **src/features/InfoPack/actions/sendInfoPack.ts**

```
const allowedOrigins = getAllowedOrigins();

if (allowedOrigins.size > 0) {
  const origin = context?.request.headers.get("origin");

  if (!origin || !allowedOrigins.has(origin)) {
    throw new ActionError({
      code: "FORBIDDEN",
      message: INFO_PACK_ERRORS.action.forbidden,
    });
  }
}
```

**Why it’s structured this way**

- allowedOrigins.size > 0
    
    → only enforce the rule when configured
    
- context?.request
    
    → Astro passes context automatically when calling the action
    
    → tests can inject it manually
    
- Server-side origin checks matter; client-side checks do not
    

---

## **Where context comes from**

  

Astro Actions invoke handlers like this:

```
handler: async (input, context) => { ... }
```

context is a **subset of Astro’s request context**, and includes:

- request (headers, method, URL)
    
- other runtime metadata (adapter-dependent)
    

  

This is why you can safely read:

```
context.request.headers.get("origin")
```

---

## **Required environment setup**

  

You **must** set ALLOWED_ORIGINS in **Preview + Production**.

  

Include **exact origins** (scheme + domain):

```
https://yourdomain.com
https://www.yourdomain.com
```

For local dev (optional but recommended):

```
http://localhost:4321
```

> If ALLOWED_ORIGINS is not set, origin checking is effectively disabled.

---

## **What this does NOT do**

- ❌ Does not stop bots that POST directly with spoofed or missing headers
    
- ❌ Does not replace rate limiting
    
- ❌ Does not replace CSRF tokens for authenticated actions
    

  

This is a **layer**, not a full security solution.

---

## **Tests added (what they prove)**

- Allowed origin → handler proceeds
    
- Disallowed origin → ActionError(FORBIDDEN)
    
- Missing origin (when allowlist enabled) → blocked
    
- Side-effects are never triggered for blocked requests
    

---

## **Practical checklist**

- Set ALLOWED_ORIGINS in Vercel (Preview + Production)
    
- Include exact scheme (https:// vs http://)
    
- Add INFO_PACK_ERRORS.action.forbidden
    
- Keep origin checks **before** side effects (email, storage)
    

---

## **Manual testing: Allowed Origins**

  

### **Pre-req**

1. Set ALLOWED_ORIGINS in .env or Vercel
    
2. Restart dev server:
    

```
npm run dev
```

  

---

### **Test A — Allowed origin (PASS)**

- Open the site using an allowed domain (or localhost if included)
    
- Submit the form normally
    

  

**Expected**

- Success response
    
- No forbidden error
    

---

### **Test B — Disallowed origin via curl (FAIL)**

```
curl -i -X POST "http://localhost:4321/_actions/sendInfoPack/" \
  -H "Origin: https://bad.example" \
  -F "fullName=Ada Lovelace" \
  -F "email=ada@example.com" \
  -F "phone=+12345" \
  -F "website="
```

**Expected**

- Request rejected
    
- No email / no side effects
    

---

### **Test C — Missing Origin header (FAIL if allowlist enabled)**

```
curl -i -X POST "http://localhost:4321/_actions/sendInfoPack/" \
  -F "fullName=Ada Lovelace" \
  -F "email=ada@example.com" \
  -F "phone=+12345" \
  -F "website="
```

**Expected**

- Blocked (FORBIDDEN)
    

  

If it passes, the allowlist is not active.

---

### **Test D — Allowed origin via curl (PASS)**

```
curl -i -X POST "http://localhost:4321/_actions/sendInfoPack/" \
  -H "Origin: http://localhost:4321" \
  -F "fullName=Ada Lovelace" \
  -F "email=ada@example.com" \
  -F "phone=+12345" \
  -F "website="
```

---

## **Reinforcement questions**

  

Answer these to confirm understanding:

1. What happens if ALLOWED_ORIGINS is empty in production?
    
2. Why do we block **missing Origin** when the allowlist exists?
    
3. Can a bot still hit this endpoint despite origin checks? How?
    

  

If you want, next we can:

- freeze this as “done”
    
- or add a **minimal CSRF token** without introducing Redis / KV.