## **Allowed Origins (Origin Allowlist) — Astro Action Hardening**

  

### **What problem this solves**

  

Blocks **cross-site form submissions** to your Astro Action from random websites by only accepting requests whose Origin header matches a known allowlist.

  

This is **not full CSRF protection**. It’s a strong “cheap gate” that reduces abuse for public forms.

---

### **How it works (high level)**

1. You define a comma-separated env var of allowed domains:
    

  

- ALLOWED_ORIGINS="https://example.com,https://www.example.com"
    

  

2. On every action call, read the request Origin header:
    

  

- If allowlist is configured and:
    
    - Origin is missing **or**
        
    - Origin is not in the allowlist
        
        → reject with ActionError({ code: "FORBIDDEN" })
        
    

  

3. If allowlist is not configured, the origin check is skipped (dev convenience).
    

---

### **File:** 

### **src/features/InfoPack/config/allowed-origins.ts**

```
export function getAllowedOrigins(): Set<string> {
  const rawAllowedOrigins = import.meta.env.ALLOWED_ORIGINS ?? "";
  return new Set(
    rawAllowedOrigins
      .split(",")
      .map((s) => s.trim())
      .filter(Boolean),
  );
}
```

Key points:

- .split(",") turns "a,b,c" into an array.
    
- .trim() removes whitespace around entries.
    
- .filter(Boolean) removes empty strings (e.g. trailing commas).
    
- Set gives fast lookup: allowedOrigins.has(origin).
    

---

### **File:** 

### **src/features/InfoPack/actions/sendInfoPack.ts**

```
const allowedOrigins = getAllowedOrigins();
if (allowedOrigins.size > 0) {
  const origin = context?.request.headers.get("origin");
  if (!origin || !allowedOrigins.has(origin)) {
    throw new ActionError({
      code: "FORBIDDEN",
      message: INFO_PACK_ERRORS.action.forbidden,
    });
  }
}
```

Why it’s written like this:

- allowedOrigins.size > 0: only enforce the rule when configured.
    
- context?.request...: context exists when Astro calls the action handler; tests can pass it in manually.
    
- Origin is checked on the server (client checks are useless for security).
    

---

### **Where** 

### **context**

###  **comes from**

  

Astro Actions call your handler as:

```
handler: async (input, context) => { ... }
```

context is a subset of Astro’s request context and includes request, so you can access headers.

---

### **Required env setup**

  

Set ALLOWED_ORIGINS for **Preview + Production** (and local if you want strict dev):

- https://yourdomain.com
    
- https://www.yourdomain.com
    
- include any other real domains you use for the same form
    

  

If you don’t set it, origin allowlisting is effectively off.

---

### **What this does NOT do**

- Doesn’t stop bots that directly POST to your action endpoint with a spoofed/missing Origin (some clients can omit it).
    
- Doesn’t replace **rate limiting**.
    
- Doesn’t replace real CSRF tokens for authenticated user actions.
    

---

### **Tests added (what they prove)**

- Allowed origin → handler proceeds.
    
- Disallowed origin → throws ActionError with code FORBIDDEN.
    
- Missing origin (when allowlist enabled) → blocked.
    

---

### **Practical checklist**

- Add ALLOWED_ORIGINS to Vercel env vars (Preview + Production)
    
- Confirm the exact scheme matches (https:// vs http://)
    
- Add/verify INFO_PACK_ERRORS.action.forbidden
    
- Keep this check _before_ side-effects (email/sheets)
    

  Here are **manual tests** you can do, and you can paste this as the end of your Obsidian note.

---

## **Manual testing: Allowed Origins**

  

### **Pre-req (make the test meaningful)**

1. Set ALLOWED_ORIGINS in your env:
    

  

- Local: in .env (or .env.local)
    
- Vercel: Project → Settings → Environment Variables
    

  

Example:

```
ALLOWED_ORIGINS=https://harmony-music-academy.vercel.app,https://harmonymusicacademy.ie
```

2. Restart dev server after changing env:
    

```
npm run dev
```

---

## **Test A — Allowed origin (should PASS)**

  

This is the “normal user” case.

1. Open your site in the browser using one of your allowed domains (or localhost **if** localhost is in ALLOWED_ORIGINS).
    
2. Submit the Info Pack form normally.
    

  

Expected:

- Success message / redirect
    
- No FORBIDDEN error
    

---

## **Test B — Disallowed origin via curl (should FAIL with FORBIDDEN)**

  

This simulates a cross-site request by forcing an Origin header.

  

**Step 1: get the action endpoint**

Open DevTools → Network, submit once, and copy the request URL (it’ll look like /_actions/...).

  

**Step 2: run curl**

Replace <ACTION_URL> with what you copied:

```
curl -i -X POST "<ACTION_URL>" \
  -H "Origin: https://bad.example" \
  -F "fullName=Ada Lovelace" \
  -F "email=ada@example.com" \
  -F "phone=+12345" \
  -F "website="
```

Expected:

- HTTP status corresponds to forbidden (Astro will wrap it, but your handler throws ActionError code FORBIDDEN)
    
- No email sending / no side effects
    

---

## **Test C — Missing Origin header (should FAIL if allowlist enabled)**

  

If ALLOWED_ORIGINS is set, your code blocks missing Origin too.

```
curl -i -X POST "<ACTION_URL>" \
  -F "fullName=Ada Lovelace" \
  -F "email=ada@example.com" \
  -F "phone=+12345" \
  -F "website="
```

Expected:

- Blocked (FORBIDDEN)
    

  

If it _doesn’t_ block, it means either:

- ALLOWED_ORIGINS wasn’t picked up, or
    
- you’re not hitting the action you think you are.
    

---

## **Test D — Allowed origin via curl (should PASS)**

```
curl -i -X POST "<ACTION_URL>" \
  -H "Origin: https://harmonymusicacademy.ie" \
  -F "fullName=Ada Lovelace" \
  -F "email=ada@example.com" \
  -F "phone=+12345" \
  -F "website="
```

Expected:

- Success response
    
- Side effects only happen in the human path (and only if your deliver service actually does something).
    

---

### **Quick sanity check (debug)**

  

Temporarily log these during manual testing:

```
console.log("ALLOWED_ORIGINS:", [...getAllowedOrigins()]);
console.log("ORIGIN:", origin);
```

Just don’t forget to remove them after you confirm behaviour.

---

### **Reinforcement questions (answer these now)**

1. What happens if ALLOWED_ORIGINS is empty in production?
    
2. Why do we reject missing Origin when allowlist is enabled?
    
3. Can a bot still hit your endpoint even with origin checks? How?