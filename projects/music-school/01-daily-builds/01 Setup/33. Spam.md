### **1)** 

### **infoPack.schema.ts**

###  **— add a honeypot field that always exists**

  

**What we did:** added website to the Zod schema so the server action can reliably check it.

```ts
// Honeypot field: hidden from humans, bots often fill it.
// Normalizes null/undefined → "" so `website` is always a string for simple `.trim()` checks.
website: z.string().trim().nullable().optional().transform((v) => v ?? ""),
```

---

### **2)** 

### **HoneypotWebsiteInput.tsx**

###  **— add a hidden input in the form**

  

**What we did:** created an input named website, hidden off-screen so humans never see it, but bots might fill it.

```tsx
<div
  aria-hidden="true"
  className="absolute -left-[10000px] top-auto h-px w-px overflow-hidden"
>
  <Input
    id="website"
    name="website"
    type="text"
    tabIndex={-1}
    autoComplete="new-password"
  />
</div>
```

Key points:

- name="website" must match the schema field name.
    
- Hidden by positioning, not display:none (some bots skip invisible fields).
    
- tabIndex={-1} keeps keyboard users from accidentally landing on it.
    

---

### **3)** 

### **InfoPackFormReact.tsx**

###  **— include the honeypot input inside the** 

### `**<form>**`

  

**What we did:** rendered the honeypot component inside the form so it gets submitted with the rest of the fields.

```tsx
<form onSubmit={onSubmit}>
  {/* ...real fields... */}

  <HoneypotWebsiteInput />

  {/* ...submit button... */}
</form>
```

---

### **4)** 

### **sendInfoPack.ts**

###  **— block spam in the server action (not the client)**

  

**What we did:** added an early return inside the server action handler:

- If website has any value → treat as bot
    
- Return success anyway (so the bot doesn’t learn it was blocked)
    
- Don’t send email, don’t log
    

```ts
// Honeypot: humans won’t fill `website`. If it has a value, treat as bot.
// Return success to avoid tipping off spam scripts (don’t send email, don’t log).
if (input.website?.trim()) {
  return { success: true, message: "OK" };
}
```

Then your normal flow continues:

```ts
try {
  // send Resend email here
  return { success: true, message: "Info pack emailed successfully" };
} catch (err: unknown) {
  Sentry.captureException(err);
  // rethrow ActionError or throw a new one
}
```


## **Manual Honeypot Tests (Verified Working)**

  

### **Test 1 — Normal Human Submission**

  

**Goal:** Ensure real users are unaffected.

  

**Steps:**

1. Open the Info Pack form normally.
    
2. Fill in all visible fields.
    
3. Do **not** touch the hidden website field.
    
4. Submit the form.
    

  

**Expected Result:**

- Form submits successfully.
    
- Email is sent (or normal success flow).
    
- Redirects to /thank-you (or success UI).
    
- **No “HONEYPOT TRIGGERED” log appears.**
    

---

### **Test 2 — Bot Simulation (Honeypot Filled)**

  

**Goal:** Ensure bots are silently blocked.

  

**Steps (DevTools method):**

1. Open the Info Pack page.
    
2. Open **DevTools → Console**.
    
3. Run:
    

```js
document.querySelector('input[name="website"]').value = "spam";
```

3.   
    
4. Submit the form.
    

  

**Observed Result (Confirmed):**

```bash
HONEYPOT TRIGGERED
[200] POST /_actions/sendInfoPack/
[200] /thank-you
```

**Expected Behavior:**

- Server logs HONEYPOT TRIGGERED.
    
- Request returns **200 OK**.
    
- User is redirected to /thank-you.
    
- **No email is sent.**
    
- Bot receives no error signal.
    

---

### **Why This Is Correct**

- Bots are blocked **server-side** (cannot bypass).
    
- Bots are **not alerted** (no 4xx / 5xx).
    
- Real users are unaffected.
    
- Minimal complexity, no CAPTCHA friction.
    
- OWASP-recommended low-friction spam defense.