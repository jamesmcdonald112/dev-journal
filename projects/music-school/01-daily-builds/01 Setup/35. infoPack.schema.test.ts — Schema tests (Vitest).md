### **Purpose**

  

Locks down the Zod schema behaviour so validation + transforms can’t regress (spam honeypot included).

  

### **Key idea: test the schema, not the UI**

- We call infoPackSchema.parse(...) for success cases.
    
- We use expect(() => infoPackSchema.parse(...)).toThrow() for failure cases.
    

  

### **Helper:** 

### **makeValidInput(overrides)**

  

Creates a baseline object that definitely passes validation, then lets each test override one field.

```
type InfoPackInput = z.input<typeof infoPackSchema>;

function makeValidInput(overrides: Partial<InfoPackInput> = {}): InfoPackInput {
  return {
    fullName: "Jane Doe",
    email: "jane@example.com",
    phone: "+1 234-567",
    studentAge: 10,
    message: "Hello",
    website: "",
    ...overrides,
  };
}
```

- `Partial<InfoPackInput>` = you can override only the field you’re testing.
    
- = {} = if you pass nothing, overrides is just an empty object (no magic defaults).
    

  

### **Use real limits from config (no hardcoded numbers)**

```
const {
  fullName: FULL_NAME_LIMITS,
  email: EMAIL_LIMITS,
  message: MESSAGE_LIMITS,
  studentAge: STUDENT_AGE_LIMITS,
} = FORM_LIMITS;
```

### **What’s covered**

- **happy path:** trims + normalizes output
    
- **fullName:** trims, min/max length throws
    
- **email:** trims + lowercases, invalid throws, too-long throws
    
- **phone:** regex acceptance + rejection
    
- **studentAge:** accepts number + string "8" (coerce), rejects decimals, enforces min/max, optional
    
- **message:** optional, trims whitespace-only to "", max length throws
    
- **website (honeypot):** missing/null/whitespace → "", non-empty remains trimmed value
    

  

### **Why this matters**

- Guarantees website is always a string after parsing → honeypot check stays safe.
    
- If FORM_LIMITS change later, tests stay aligned automatically.
    
