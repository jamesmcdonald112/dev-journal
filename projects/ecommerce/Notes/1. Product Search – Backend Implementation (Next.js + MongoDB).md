# **ğŸŸ¦ Product Search â€“ Backend Implementation (Next.js + MongoDB)**

## ** Goal**

  

Implement backend search so `/api/products?query=<keyword>` returns products filtered by:

- title
    
- shortDescription
    
- Case-insensitive
    
- MongoDB regex search
    

---

## **ğŸ“Œ Relevant Docs**

  

### **ğŸ”¹ Next.js â€” Route Handlers**

  

Use NextRequest and request.nextUrl.searchParams:

https://nextjs.org/docs/app/api-reference/functions/next-request#url-query-parameters

  

### **ğŸ”¹ MongoDB â€”**Â 

### **$regex**

### Â **operator**

  

Pattern matching in queries:

https://www.mongodb.com/docs/manual/reference/operator/query/regex/

  

### **ğŸ”¹ Mongoose â€”**Â 

### **Model.find()**

  

Querying collections with filters:

https://mongoosejs.com/docs/queries.html

---

## **ğŸ“‚ File:**Â 

## **app/api/products/route.ts**

```ts
import { type NextRequest, NextResponse } from "next/server";
import z, { ZodError } from "zod";
import { createProduct } from "@/app/features/products/api/createProduct";
import { getProductsBySearch } from "@/app/features/products/api/getProducts";
import { productSchema } from "@/app/features/products/schemas/product.schema";
import type { Product } from "@/app/features/products/types/product";

export async function GET(request: NextRequest): Promise<NextResponse> {
  try {
    const searchParams = request.nextUrl.searchParams;
    const query: string = searchParams.get("query") || "";

    const products: Product[] = await getProductsBySearch(query);
    return NextResponse.json({ success: true, data: products });
  } catch (error: unknown) {
    return handleError(error);
  }
}

export async function POST(request: NextRequest): Promise<NextResponse> {
  try {
    const json: unknown = await request.json();
    const parsedBody: Product = productSchema.parse(json);

    const product = await createProduct(parsedBody);
    return NextResponse.json({ success: true, data: product }, { status: 201 });
  } catch (error: unknown) {
    return handleError(error);
  }
}

function handleError(error: unknown, status = 500): NextResponse {
  if (error instanceof ZodError) {
    const tree = z.treeifyError(error);
    return NextResponse.json({ success: false, errors: tree }, { status: 400 });
  }
  const message = error instanceof Error ? error.message : "Unknown error";
  return NextResponse.json({ success: false, error: message }, { status });
}
```

---

## **ğŸ“‚ File:**Â 

## **app/features/products/api/getProducts.ts**

```ts
import dbConnect from "@/app/lib/mongodb";
import { ProductModel } from "../models/Product";
import type { Product } from "../schemas/product.schema";

export async function getAllProducts(): Promise<Product[]> {
  await dbConnect();
  return await ProductModel.find({});
}

export async function getProductsBySearch(query: string): Promise<Product[]> {
  await dbConnect();

  if (query === "") return getAllProducts();

  return await ProductModel.find({
    $or: [
      { title: { $regex: query, $options: "i" } },
      { shortDescription: { $regex: query, $options: "i" } },
    ],
  });
}
```

---

## **ğŸ§ª Postman Test Examples**

  

### **1ï¸âƒ£ Get all products**

```
GET http://localhost:3000/api/products
```

### **2ï¸âƒ£ Search â€œphoneâ€**

```
GET http://localhost:3000/api/products?query=test
```

### **3ï¸âƒ£ Search â€œcase-insensitiveâ€**

```
GET http://localhost:3000/api/products?query=TEST
```

---

## **ğŸ“ Notes**

- request.nextUrl.searchParams is the **correct Next.js App Router API** for reading query strings.
    
- MongoDB regex with $options: "i" makes matches **case-insensitive**.
    
- Using $or allows searching multiple fields.
    
- No pagination yet â€” add later if needed.
    